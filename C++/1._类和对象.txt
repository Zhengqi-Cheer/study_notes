Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2024-12-05T15:26:34+08:00

====== 1. 类和对象 ======
Created 星期四 05 十二月 2024





C++面向对象的三大特征行为：//**封装、继承、多态**//。认为万事万物//**皆为对象**//，对象上有其属性和行为。










== ====类（class）和对象 ==




	1. 封装：(1) 将属性和行为作为一个整体。 (2)  属性和行为可放在不同的权限下，加以控制。
		a. 公共权限（public）：成员 类内、外都可访问。
		b. 保护权限（protected）：成员 类内可访问。 儿子可访问父亲的访问权限。
		c. 私有权限（private）：成员 类内可访问。 儿子不可访问父亲的访问权限。可编程自己控制可读可写。
	2. 对象：具体的对象，如人类为类，个人为对象。
	3. 类
		class 关键字代表设计一个类，后面紧跟类名称。
		属性是变量，行为是函数。
		ps:骚啊，还能用行为给属性赋值。 

		实例化：

			class 类名称
			{
				权限；
				属性；/* 一般是变量 */
				行为；/* 一般是函数 */
			};
			类名称 对象名；

####类和结构体的区别
	可以使用结构体去表示类。
	在c++中的//**默认权限**//不同，结构体的权限是public， 类的权限是private。

####对象的初始化和清理
	这个不是默认有的，编译会默认有个空函数，C++编译器会自动默认添加至少三个函数：默认构造函数（空实现，我们），默认拷贝构造函数（值拷贝），默认析构函数（空实现）。
		注意：
		1. 我们写了有参构造函数后，编译器不在提供默认构造函数，但依然提供拷贝构造函数。
		2. 我们写了拷贝构造函数后，编译器不在提供其他构造函数。
		3. 总结：写了高级高级就不提供低级构造。
	初始化：构造函数，用于创建对象是给对象的成员属性赋值，有编译器的自动调用。
		语法： 
			类名(){}
			1. 没有返回值，也不写void;
			2. 函数名与类名称相同；
			3. 构造函数可以有参数，可以发生重载；
			4. 程序调用对象时自动调用重构。有且只会调用一次。

		分类：有参构造和无参构造 或 普通构造和拷贝构造(参数为同类对象，引用传参)。
		调用：
			1. 括号调用：
				a. class名称 对象名； ---默认构造调用 [[/*]] 注意不要写()，否则无法创建对象，编译器认为是函数声明 */
				b. class名称 对象名(参数)  ---有参构造调用
				c. class名称 对象名(对象)  ---拷贝构造调用
			2. 显示法：
				a. class名称 对象名 = class名称 (参数) ---有参构造调用
				b. class名称 对象名 = class名称 (对象)  ---拷贝构造调用
				注意：
					1. 匿名对象（class名称(参数)），执行完后立即释放。
					2. 不要使用拷贝构造调用 触发匿名对象，会报错。
			3. 隐式转换法：

				a. class名称 对象名 = 参数；（//**__多个参数呢？__**//）。
			4. 拷贝构造函数的调用时机：
				a. 使用已创建完毕的对象初始化另一个对象；
				b. 函数传参；
				c. 函数返回局部对象；

	清理：析构函数，对象销毁前系统自动调用，执行一些清理工作。
		语法： 
			~类名(){}
			1. 没有返回值，也不谢void;
			2. 函数名与类名称相同，名称前加上~；
			3. 构造函数不可有参数，不可以发生重载；
			4. 程序摧毁对象前自动调用析构。有且只会自动调用一次。

####深拷贝与浅拷贝
	浅拷贝：编译器提供的拷贝构造(简单的值拷贝，对于一些指针的属性可能再次堆区内存重复释放)；
	深拷贝：解决浅拷贝存在的问题，非简单的值拷贝。

	To be continue!
	
	
	

== ====初始化列表 ==
	1. 语法
		a. 类名称(): 属性1(参数)，属性2(参数)，属性3(参数)，...{}
		b. 类名称(int 变量1 , int 变量2 , int 变量3 , ...): 属性1(变量1)，属性2(变量2)，属性3(变量3)，...{}
		c. __注意{}，不要漏掉。__


== ====类对象作为类成员 ==

		问：先构造类成员还是类对象？
		答：构造时先类成员，再对象；析构时先对象，后类成员。
		

== ====对象的静态成员与静态函数存储位置不同。 ==
	1. 静态成员变量：
		a. 所有成员共享同一份数据；
		b. 在编译阶段分配内存；
		c. 类内声明(定义)，内外初始化(格式： 类型 类名称::成员 = 参数，如 int person::age = 100)。
		d. 两种访问方式：
			1. 通过对象访问；
			2. 通过类名访问：类名::静态成员变量；
		e. 注意：有属性，类外不能访问到私有属性。
	2. 静态成员函数：
		a. 只能访问静态成员变量
		b. 所有成员共享同一个函数(为什么强调这个??????)
		c. 两种访问方式：
			1. 通过对象访问；
			2. 通过类名访问：类名::静态成员函数；
#######成员变量和成员函数分开储存
		1. sizeof一个空类（没有属性和函数），占1个字节。
		2. 静态类成员、函数 储存在四区中~~的全局区~~。
#### this指针--
		是指针常量(指向不可变)；


		1. 解决名称冲突；
		2. 返回对象本身用*this;
		3. this 指针指向被调用的成员函数所属的对象。(链式编程思想)
#### 空对象可调类函数--//**可调用函数，但是函数不能调用空对象的非静态属性**//。
	1. 若用到this指针，需加以判断保证代码的健壮性。
#### 常函数与常对象--const修饰的
	1. 常函数：
		a. 格式： 函数名 const; ps ：这个const修饰的是this指针；
		b. 常函数不可修改成员属属性。
		c. 成员属性声明是加了关键字**mutable、static**后，在常函数中依然可修改。
	2. 常对象：
		a. 只能调用常函数。
		b. 成员属性声明是加了关键字**mutable、static**后，在常对象中依然可修改。







